## Что сработало хорошо

1) Handoff и маршрутизация: router_node явно принимает решение (intent) и пишет это в handoff_log. Это делает маршрут объяснимым (почему выбрали именно coding / daily / literature и т.д.).

2) Паттерн “Supervisor/Reviewer loop”: reviewer_node управляет циклом добора информации через need_more + focus → gather_tools_node. Это реализует “контроль качества” и автоматический возврат к инструментам.

3) Tool calling: в задачах “coding/daily/literature” инструменты реально помогают: поиск заметок, сохранение полезных паттернов, вычисления дат/формул. Использование create_react_agent облегчает “думать + действовать” без ручного парсинга tool calls.

4) Управление памятью: есть две формы памяти:

- оперативная: history (последние N сообщений); 
- долговременная: notes.json + retrieval (RAG-lite).

Таким образом система может опираться на сохраненные ранее подсказки.

## Где система ошибалась

1) Зацикливание на инструментах: иногда reviewer выставлял need_more=true даже для простых задач, из-за чего граф ходил agent → reviewer → gather_tools → agent …. Решение частично есть: round/max_rounds, но важно ещё улучшить критерии reviewer и остановку.

2) Избыточные tool-calls: ReAct-агент может вызвать search_user_notes многократно “на всякий случай”. Без штрафа за вызовы инструментов модель склонна переиспользовать tools.

3) Неверный intent: роутер иногда путает “architecture vs coding”, если запрос смешанный (“как спроектировать state и покажи код”). Это нормально для базового router-а, но можно улучшить: multi-intent или “router → уточняющий вопрос”.

4) Память используется не всегда “умно”: retrieval по заметкам — простой (по токенам). Иногда он либо не находит нужное, либо вытаскивает нерелевантное совпадение.

## Как бы развивала систему дальше

А) Улучшить reviewer: добавить отдельные критерии качества по intent (для coding: наличие блока кода, для literature: наличие критериев отбора и т.п.) и делать need_more=true только если реально есть “что добыть” инструментами.

Б) Сделать структурированный tool_context: не хранить сырой текст, а агрегировать “наблюдения” по типам, чтобы writer/агенты получали чистый контекст.

В) Добавить новые инструменты под реальные задачи:
Scholar для literature (не смогла найти доступное API), “file tools” для работы с репозиторием/ноутбуком.

Г) Сделать более глубокую память: embeddings + векторное хранилище (FAISS/Chroma),  авто-суммаризацию истории в “user profile”.
Ввести supervisor-агента отдельным узлом, который распределяет подзадачи между несколькими агентами (например, architecture + coding вместе).